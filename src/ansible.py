import json
import os
import time

import yaml

from src.utils.config import EC2_KEY_PAIR_NAME, DEFAULT_REGION, UBUNTU_AMI_ID, DEFAULT_EC2_INSTANCE_TYPE, \
    DEFAULT_SECURITY_GROUP_NAME
from src.utils.credentials_handler import get_aws_access_credentials
from src.utils.user_input_handler import get_user_input, InputType

PLAYBOOK_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "ansible_playbooks")
INVENTORY_FILE = os.path.join(PLAYBOOK_DIR, "dynamic_inventory.ini")
EC2_IPS_FILE = os.path.join(PLAYBOOK_DIR, "ec2_instance_ips.yaml")
RELATIVE_PEM_PATH = f"../{EC2_KEY_PAIR_NAME}.pem"


def prompt_group_size(group_num):
    """
    Prompt the user for a group size (1-2) using the input utility.
    :param group_num: int, the group number (1 or 2)
    :return: int, validated group size
    """
    available_options = [1, 2]
    val = get_user_input(
        f"Enter number of instances for group {group_num} (1-2):",
        input_type=InputType.INT,
        available_options=available_options
    )
    return val


def run_playbook(playbook, extra_vars=None, inventory=None):
    """
    Run an Ansible playbook with optional extra_vars and inventory using os.system.
    :param playbook: str, playbook filename
    :param extra_vars: dict, extra variables to pass to the playbook
    :param inventory: str, inventory file path
    """
    cmd = f"ansible-playbook {os.path.join(PLAYBOOK_DIR, playbook)}"

    # Add extra vars if provided. Pass as a JSON string for cross-platform compatibility.
    if extra_vars:
        cmd += f" --extra-vars '{json.dumps(extra_vars)}'"

    # Add inventory if provided
    if inventory:
        cmd += f" -i {inventory}"

    # Run the command and check exit code
    exit_code = os.system(cmd)
    if exit_code != 0:
        print(f"Error running playbook {playbook}. Exit code: {exit_code}")
        exit(1)


def read_instance_ips():
    """
    Read instance IPs from the playbook output file.
    :return: tuple of lists (group1_ips, group2_ips)
    """
    # Ensure the ips file exists - it should be created by the EC2 playbook
    if not os.path.exists(EC2_IPS_FILE):
        print(f"Instance IPs file not found: {EC2_IPS_FILE}\nMake sure the EC2 playbook writes IPs to this file.")
        exit(1)

    # Read the IPs from the YAML file
    with open(EC2_IPS_FILE) as f:
        ips = yaml.safe_load(f)

    # Validate the structure - we expect keys 'group1' and 'group2'
    if not ips or "group1" not in ips or "group2" not in ips:
        print(f"Invalid IPs file format. Expected keys: 'group1', 'group2'.")
        exit(1)

    return ips["group1"], ips["group2"]


def setup_master_ssh_keys():
    """
    Ensure the PEM file is available locally for SSH access to EC2 hosts.
    """
    # Ensure PEM file exists within the project directory
    pem_src = os.path.abspath(os.path.join(os.path.dirname(__file__), RELATIVE_PEM_PATH))
    if not os.path.exists(pem_src):
        print(f"PEM file not found: {pem_src}. Please ensure your AWS key pair PEM file is present.")
        exit(1)

    # Set appropriate permissions on the PEM file
    try:
        os.chmod(pem_src, 0o600)
    except Exception as e:
        print(f"Error setting permissions on PEM file: {e}")
        exit(1)


def check_ssh_connectivity(hosts, key_path):
    """
    Check SSH connectivity to all hosts using the provided key.
    :param hosts: list of str, host IPs
    :param key_path: str, path to private key
    """
    # Try to SSH into each host up to 10 times
    for ip in hosts:
        print(f"Checking SSH connectivity to {ip}...")
        for attempt in range(10):
            # Redirect stdout to /dev/null on Unix-like systems and NUL on Windows.
            # This adjustment for Windows compatibility was generated by AI.
            # It was added to avoid issues on Windows systems, but it has not been tested.
            null_device = "NUL" if os.name == "nt" else "/dev/null"
            command = f"ssh -o StrictHostKeyChecking=no -i '{key_path}' ubuntu@{ip} echo connected > {null_device}"
            exit_code = os.system(command)

            # Check result
            if exit_code == 0:
                print(f"SSH to {ip} successful.")
                break
            else:
                print(f"Attempt {attempt + 1}/10 failed.")
                time.sleep(10)
        else:
            print(f"ERROR: Cannot SSH to {ip} after 10 attempts. Check key, user, and security group.")
            exit(1)


def create_dynamic_inventory_file(group1_ips, group2_ips):
    """
    Create a dynamic inventory file in INI format for Ansible, including SSH user and key.
    :param group1_ips: list of IPs for group 1
    :param group2_ips: list of IPs for group 2
    """
    # Use absolute path for the PEM file
    key_path = os.path.abspath(os.path.join(os.path.dirname(__file__), RELATIVE_PEM_PATH))
    quoted_key_path = f'"{key_path}"'  # Use absolute path and quote it

    # Write the inventory file

    # Create group 1 section
    lines = ['[group1]']
    for ip in group1_ips:
        lines.append(f"{ip} ansible_user=ubuntu ansible_ssh_private_key_file={quoted_key_path}")
    lines.append('')

    # Create group 2 section
    lines.append('[group2]')
    for ip in group2_ips:
        lines.append(f"{ip} ansible_user=ubuntu ansible_ssh_private_key_file={quoted_key_path}")
    lines.append('')

    # Create all children section
    lines.append('[all:children]')
    lines.append('group1')
    lines.append('group2')

    # Write to file
    with open(INVENTORY_FILE, 'w') as f:
        f.write('\n'.join(lines))


def main():
    """
    Main entry point for launching EC2 groups and installing Apache2.
    """
    # Ensure SSH keys are set up before any operations
    setup_master_ssh_keys()

    print("AWS EC2 Group Launcher & Apache Installer")
    group1_size = prompt_group_size(1)
    if not group1_size:
        return

    group2_size = prompt_group_size(2)
    if not group2_size:
        return

    # Get config variables and credentials and run EC2 generator playbook
    aws_access_credentials = get_aws_access_credentials()
    extra_vars = {
        "group1_size": group1_size,
        "group2_size": group2_size,
        "key_name": EC2_KEY_PAIR_NAME,
        "region": DEFAULT_REGION,
        "image_id": UBUNTU_AMI_ID,
        "instance_type": DEFAULT_EC2_INSTANCE_TYPE,
        "security_group": DEFAULT_SECURITY_GROUP_NAME,
        "aws_access_key": aws_access_credentials.get('AWS_ACCESS_KEY_ID'),
        "aws_secret_key": aws_access_credentials.get('AWS_SECRET_ACCESS_KEY')
    }
    print("Launching EC2 instances...")
    run_playbook("ec2_generator_playbook.yml", extra_vars=extra_vars)

    # Read instance IPs from playbook output
    group1_ips, group2_ips = read_instance_ips()
    print(f"Group 1 IPs: {group1_ips}")
    print(f"Group 2 IPs: {group2_ips}")

    # Create dynamic inventory file
    create_dynamic_inventory_file(group1_ips, group2_ips)

    # Check SSH connectivity to all instances
    pem_path = os.path.abspath(os.path.join(os.path.dirname(__file__), RELATIVE_PEM_PATH))
    check_ssh_connectivity(group1_ips + group2_ips, pem_path)

    # Prompt user to select group for Apache installation
    available_groups = [1, 2]
    group_choice = get_user_input(
        "Which group to install Apache2 on? (1 or 2):",
        input_type=InputType.INT,
        available_options=available_groups
    )
    if not group_choice:
        return
    target_group = "group1" if group_choice == 1 else "group2"

    # Run playbook to install Apache2
    print("Installing Apache2 on selected group...")
    apache_install_extra_vars = get_aws_access_credentials()
    apache_install_extra_vars["target_group"] = target_group
    run_playbook(
        "install_apache_playbook.yml",
        extra_vars=apache_install_extra_vars,
        inventory=INVENTORY_FILE
    )
    print("Apache2 installation playbook completed.")


if __name__ == "__main__":
    main()
